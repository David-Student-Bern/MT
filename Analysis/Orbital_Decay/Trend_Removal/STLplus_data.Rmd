---
title: "STL_plus"
author: "David Schwarz"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Read generated Data

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(readr)
library(fs)

# Function to find repo root by walking up until marker is found
find_repo_root <- function(marker = "README.md") {
  current <- path_abs(".")
  parents <- c(current, path_dir(path_split(current)[[1]]))
  
  for (p in path_split(current)[[1]]) {
    candidate <- path_join(c(path_dir(path_abs(".")), rep("..", length(p))))
  }
  
  # Simpler approach than above: loop over parent dirs
  current <- path_abs(".")
  while (current != path_dir(current)) {
    if (file_exists(path(current, marker))) {
      return(current)
    }
    current <- path_dir(current)
  }
  
  stop(sprintf("Could not find repo root with marker '%s'", marker))
}

# Find repo root using a known file
repo_root <- find_repo_root("README.md")

# Path to the CSV file
GFOC_path <- path(repo_root, "Dataset", "Dataset_MSc", "GFOC_RDCDFI.csv")

# Columns needed
columns_needed <- c("time", "orbital_decay")

# Try to load with limited columns first
data <- tryCatch(
  {
    # Use readr::read_csv for efficiency (similar to pandas)
    dat <- read_csv(GFOC_path, col_select = all_of(columns_needed))
    message(sprintf("Successfully loaded data with shape: %d rows, %d cols",
                    nrow(dat), ncol(dat)))
    dat
  },
  error = function(e) {
    if (grepl("cannot allocate memory", e$message)) {
      message("Still running out of memory. Loading in chunks...")
      
      # Chunked read
      chunk_list <- list()
      chunksize <- 50000
      
      read_csv_chunked(
        GFOC_path,
        callback = DataFrameCallback$new(function(x, pos) {
          chunk_list[[length(chunk_list) + 1]] <<- x
        }),
        col_select = all_of(columns_needed),
        chunk_size = chunksize
      )
      
      dat <- do.call(rbind, chunk_list)
      message(sprintf("Successfully loaded data in chunks with shape: %d rows, %d cols",
                      nrow(dat), ncol(dat)))
      dat
    } else {
      stop(e)
    }
  }
)

```

## Some modifications to the dataset

```{r}
# remove the last 54322 rows to not include the gap in the data
n <- nrow(data)
data <- data[1:(n - 54322), ]

# Convert time to POSIXct (datetime - should already be correct but just to be sure)
data$time <- as.POSIXct(data$time, format="%Y-%m-%d %H:%M:%S")
```

split dataset into subgroups

```{r}
# Example split dates
split_dates <- c("2023-05-01 00:00:00", 
                 "2023-10-01 00:00:00", 
                 "2024-03-01 00:00:00")

# Convert to POSIXct
split_dates <- as.POSIXct(split_dates, format="%Y-%m-%d %H:%M:%S")

# Define interval boundaries
breaks <- c(min(data$time), split_dates, max(data$time))

# Create nice labels for each interval
labels <- c(
  paste0(format(breaks[1], "%Y-%m-%d"), "_to_", format(breaks[2], "%Y-%m-%d")),
  paste0(format(breaks[2], "%Y-%m-%d"), "_to_", format(breaks[3], "%Y-%m-%d")),
  paste0(format(breaks[3], "%Y-%m-%d"), "_to_", format(breaks[4], "%Y-%m-%d")),
  paste0(format(breaks[4], "%Y-%m-%d"), "_to_", format(breaks[5], "%Y-%m-%d"))
)

# Assign groups
data$group <- cut(
  data$time, 
  breaks = breaks, 
  include.lowest = TRUE, 
  right = FALSE, # ensures [start, end)
  labels = labels
)

# Split dataset by group
data_groups <- split(data, data$group)

# Preview sizes
sapply(data_groups, nrow)

```

## STL Function

```{r}
library(stlplus)

stl_decompose <- function(period_days, x, time) {
  # Convert days to half minutes (data sample rate)
  period <- period_days * 24 * 120
  cat("using a period of", period_days, "days\n")
  
  # Make sure seasonal period is odd
  seasonal <- ifelse(period %% 2 == 0, period + 1, period)
  
  # Jumps / windows
  low_pass_jump <- floor(0.15 * (period + 1))
  seasonal_jump <- low_pass_jump
  trend_jump <- floor(0.15 * 1.5 * (period + 1))
  
  # STL decomposition
  stl_result <- stlplus(
    x = x,
    t = time,
    n.p = period,
    s.window = seasonal,
    l.window = low_pass_jump,
    t.window = trend_jump
  )
  
  # Plot result
  print(
    plot(
      stl_result,
      xlab = "time",
      ylab = deparse(substitute(x))
    )
  )
  
  invisible(stl_result)
}
```

## STL Decay without Events

```{r}
res_D <- stl_decompose(
  period_days = 25,
  x = data$orbital_decay,
  time = data$time
)
```

## STL Decay with Events

```{r}
res_DwE <- stl_decompose(
  period_days = 180,
  x = data$Decay.with.Events,
  time = data$time
)
```


## STL Decay with Gaps where Events are

```{r}
res_Df <- stl_decompose(
  period_days = 6,
  x = data$Decay.filtered,
  time = data$time
)
```

## Recreate Decay without Events

```{r}

data$Decay.recreated <- res_Df$data$seasonal + res_Df$data$trend

orig <- data$Decay.without.Events

# Recreated (trend + seasonal)
recreated <- data$Decay.recreated

# Compare visually
plot(data$time, orig, type = "l", col = "black", lwd = 2,
     main = "Original vs Recreated Decay.without.Events",
     xlab = "time", ylab = "Value")
lines(data$time, recreated, col = "red", lwd = 2)
legend("topleft", legend = c("Original", "Recreated (STL)"),
       col = c("black", "red"), lty = 1, lwd = 2)

# Compare numerically (ignoring NAs)
mean_diff <- mean(abs(orig - recreated), na.rm = TRUE)
cat("Mean absolute difference:", mean_diff, "\n")
```

## Difference between Original and Recreated

```{r}
# Difference (residuals)
diff <- orig - recreated

# Plot the difference over time
plot(data$time, diff, type = "l", col = "blue", lwd = 2,
     main = "Difference: Original - Recreated",
     xlab = "time", ylab = "Difference")

abline(h = 0, col = "red", lty = 2, lwd = 2)  # reference line at 0
```


## Plot showing only the events

```{r}
# Difference (residuals)
Events <- data$Decay.with.Events - data$Decay.without.Events
rEvents <- data$Decay.with.Events - recreated

# Compare visually
plot(data$time, Events, type = "l", col = "black", lwd = 2,
     main = "Original vs Recreated Events",
     xlab = "time", ylab = "Value")
lines(data$time, rEvents, col = "red", lwd = 2)
legend("topleft", legend = c("Original", "Recreated (STL)"),
       col = c("black", "red"), lty = 1, lwd = 2)


abline(h = 0, col = "blue", lty = 2, lwd = 2)  # reference line at 0
```

# Comments

In most regards the `R` code works almost the same as the `Python` code. The only difference I noticed is in the way `stlplus` handles the 'Decay with Events'. In `R` the _Seasonal_ not only captures the two periods but also most of the events, where in `Python` there was much more of the events present in the _Residual_. In that way I would argue, that the `Python` version is slighlty better than the `R` version.

Regarding the mayor reason I tried `stlplus` in the first place: _" The `stlplus` package implements the same algorithm as the `stl` function in base R while allowing for missing data."_\
I used this ability to reproduce the 'Decay without Events' from the 'Decay with Events' by removing all the points where the difference between the two was bigger than 0.1. For real data I would need another method to decide, where the gaps should be. The tricky part of this way of creating a dataset that only contains the events is that I need to know when events are and when not. In theory I could use the flags I have, but then I am restricting myself to the events I know.

## Next steps
- try this pipeline with real data